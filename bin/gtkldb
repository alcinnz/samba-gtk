#!/usr/bin/python

#  gtkldb
#
#  Unix SMB/CIFS implementation.
#  Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#  Copyright (C) Dhananjay Sathe <dhananjaysathe@gmail.com> 2012
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#


"""Simple GTK frontend for LDB."""

from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GObject
from gi.repository import GLib
from sambagtk.dialogs import get_default_logo, AboutDialog
from sambagtk import moderngtk, ldb_widgets as widgets
import gettext
gettext.install("gtkldb")
import ldb
import os
import sys

class LdbURLDialog(Gtk.Dialog):
    """Dialog that prompts for a LDB URL.
    """
    def __init__(self, parent=None,  url_store=None):

        super(LdbURLDialog, self).__init__(parent=parent,
                    buttons=(Gtk.STOCK_CANCEL,Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_OPEN,Gtk.ResponseType.OK)
                                        )
        label = Gtk.Label(_("Enter URL:"))
        self.vbox.pack_start(label, expand=True, fill=True, padding=0)
        self.url_combo_entry =  Gtk.ComboBox.new_with_model_and_entry(url_store)
        self.url_combo_entry.set_entry_text_column(1)
        self.vbox.pack_start(self.url_combo_entry, expand=True, fill=True,
        					padding=0)
        self.set_default_response(Gtk.ResponseType.OK)
        self.show_all()

    def get_url(self):
        tree_iter = self.url_combo_entry.get_active_iter()
        if tree_iter is not None:
            model = self.url_combo_entry.get_model()
            url = model[tree_iter][1]
            return (url,False)
        else:
            entry = self.url_combo_entry.get_child()
            url = entry.get_text()
            return (url,True)


class LdbBrowser(Gtk.Window):
    """Sambagtk Ldb Browser.
    """
    def __init__(self):
        super(LdbBrowser, self).__init__()
        self.url_store = Gtk.ListStore(int, str) #for history
        self.ldb = None
        self.url_store_count =0
        self.cur_selected_dn = None
        self.search_result = None
        self.create()

    def create(self):
        self.set_title(_("Sambagtk Ldb Browser Utility"))
        self.set_default_size(800, 600)
        accel_group = Gtk.AccelGroup()

        vbox = Gtk.VBox(False, 0)
        self.add(vbox)

        #Toolbar
        self.toolbar = moderngtk.build_toolbar(self, vbox)

        self.connect_item = Gtk.ToolButton.new_from_stock(Gtk.STOCK_CONNECT)
        self.connect_item.set_tooltip_text(_("Connect to an LDB URL"))
        self.toolbar.add(self.connect_item)
        
        self.open_item = Gtk.ToolButton.new_from_stock(Gtk.STOCK_OPEN)
        self.open_item.set_tooltip_text(_("Open a LDB file"))
        self.toolbar.add(self.open_item)
        
        self.disconnect_item = Gtk.ToolButton.new_from_stock(
        											Gtk.STOCK_DISCONNECT)
        self.disconnect_item.set_tooltip_text(_("Close LDB file/connection"))
        self.disconnect_item.set_sensitive(False)
        self.toolbar.add(self.disconnect_item)
        
        self.toolbar.add(Gtk.SeparatorToolItem())
        
        self.find_item = Gtk.ToggleToolButton.new_from_stock(Gtk.STOCK_FIND)
        self.find_item.set_tooltip_text(_("Find records in open LDB file"))
        self.find_item.set_sensitive(False)
        self.toolbar.add(self.find_item)
        
        view_item = Gtk.ToolItem()
        view_button = Gtk.MenuButton()
        view_button.set_image(Gtk.Image.new_from_stock(Gtk.STOCK_PROPERTIES,
                Gtk.IconSize.LARGE_TOOLBAR))
        view_item.add(view_button)
        view_item.set_tooltip_text(_("View options..."))
        
        view_menu = Gtk.Menu()
        view_button.set_popup(view_menu)
        if hasattr(self.toolbar, 'pack_end'):
            self.toolbar.pack_end(view_item)
        else:
            self.toolbar.add(view_item)
        
        self.hide_special = Gtk.CheckMenuItem.new_with_mnemonic(
                                                    _("_Hide special entries"))
        self.hide_special.set_sensitive(False)
        view_menu.add(self.hide_special)
        
        about_item = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ABOUT)
        view_menu.add(about_item)
        view_menu.show_all()

        #   find toolbar
        self.find_bar = widgets.SearchBar(self.find_item)
        vbox.pack_start(self.find_bar, expand=False, fill=False, padding=0)

        #infobar for error reporting
        self.infobar = moderngtk.InfoBar()
        vbox.pack_start(self.infobar, expand=False, fill=False, padding=0)
        
        #main window

        pane = Gtk.HPaned()
        pane.set_position(200)
        vbox.pack_start(pane, expand=True, fill=True, padding=0)

        #   tree view
        self.dn_tree = widgets.DnTreeView()
        pane.pack1(self.dn_tree, resize=False, shrink=True)
        
        #   Attribute view
        self.attribute_stack = Gtk.Stack()
        
        blank_attributes = Gtk.Alignment(xalign=0.5, yalign=0.5,
                                        xscale=1, yscale=1)
        blank_label = Gtk.Label(_("No DN selected.\n"
                                "Select one to view it's attributes."))
        blank_label.set_justify(Gtk.Justification.CENTER)
        blank_attributes.add(blank_label)
        self.attribute_stack.add_named(blank_attributes, "blank")

        attribute_box = Gtk.VBox()
        self.attribute_stack.add_named(attribute_box, "attrs")

        #       DN label
        self.dn_label = Gtk.Label()
        self.dn_label.set_padding(0, 5)
        self.dn_label.set_alignment(Gtk.Justification.LEFT, 
                                    Gtk.Justification.CENTER)
        self.dn_label.set_selectable(True)
        attribute_box.pack_start(self.dn_label, expand=False, fill=False,
        						padding=4)
        
        #       Attribute list
        self.attributeview = Gtk.TreeView()
        self.attributemodel = Gtk.ListStore(str, str, GObject.TYPE_BOOLEAN)
        self.attributeview.set_model(self.attributemodel)
        name_renderer = Gtk.CellRendererText()
        cur_col = Gtk.TreeViewColumn(_("_Name"), name_renderer,
                                    text=0, editable=2)
        cur_col.set_sort_column_id(0)
        cur_col.set_resizable(True)
        self.attributeview.append_column(cur_col)
        value_renderer = Gtk.CellRendererText()
        cur_col = Gtk.TreeViewColumn(_("_Value"), value_renderer,
                                    text=1, editable=2)
        cur_col.set_sort_column_id(1)
        cur_col.set_resizable(True)
        self.attributeview.append_column(cur_col)
        self.attributeview.set_headers_clickable(True)

        attributeview_window = Gtk.ScrolledWindow()
        attributeview_window.add(self.attributeview)
        attribute_box.pack_start(attributeview_window, expand=True, fill=True,
                                padding=6)
        
        #       Attribute toolbar
        attribute_toolbar = moderngtk.build_inline_toolbar()
        
        self.attribute_add_item = Gtk.ToolButton(None, _("Add Attribute"))
        self.attribute_add_item.set_icon_name('list-add-symbolic')
        self.attribute_add_item.set_sensitive(False)
        attribute_toolbar.add(self.attribute_add_item)
        
        self.attribute_remove_item = Gtk.ToolButton(None, _("Remove Attribute"))
        self.attribute_remove_item.set_icon_name('list-remove-symbolic')
        self.attribute_remove_item.set_sensitive(False)
        attribute_toolbar.add(self.attribute_remove_item)
        
        attribute_box.pack_start(attribute_toolbar, expand=False, fill=False,
                                padding=0)
        
        pane.pack2(self.attribute_stack, shrink=True)

        # signals and connections

        self.connect('delete_event', self.on_self_delete)

        self.connect_item.connect('clicked', self.cb_connect)
        self.open_item.connect('clicked', self.cb_open)
        self.disconnect_item.connect('clicked', self.cb_disconnect)

        self.hide_special.connect('toggled', self.toggle_special_entries)
        about_item.connect('activate', self.show_about)
        
        self.find_bar.on_search_changed = self.dn_tree.search
        self.find_bar.on_search_closed = \
                lambda: self.dn_tree.set_search_mode(False)
        
        self.dn_tree.on_dn_selected = self.cb_dn_cursor_changed
        self.dn_tree.on_err = self.ldb_error_exception
        
        self.attributeview.connect('button_press_event', self.cb_msg_button_press)
        self.attributeview.connect('cursor_changed', self.msg_cursor_changed)
        name_renderer.connect('edited', self.cb_msg_cell_edited, 0)
        value_renderer.connect('edited', self.cb_msg_cell_edited, 1)

        self.attribute_add_item.connect('clicked', self.add_attr_cb)
        self.attribute_remove_item.connect('clicked', self.delete_attr_cb)

        self.add_accel_group (accel_group)

    def show_about(self, widget):
        aboutwin = AboutDialog("GTK LDB",
                            _("LDB database browser/editor\n"
                            "Based on Jelmer Vernooij's original Samba-GTK"),
                            None)
        aboutwin.run()
        aboutwin.destroy()

    def on_self_delete(self, widget, event):
        Gtk.main_quit()
        return False

    def set_ldb(self, ldb):
        """Change the LDB object displayed.

        :param ldb: New LDB object to use.
        """
        self.ldb = ldb
        self.disconnect_item.set_sensitive(True)
        self.find_item.set_sensitive(True)
        self.hide_special.set_sensitive(True)
        self.dn_tree.set_ldb(ldb)

    def cb_connect(self, button):
        dialog = LdbURLDialog(url_store = self.url_store)
        if dialog.run() == Gtk.ResponseType.OK:
            url,add_url_to_store = dialog.get_url()
            self.set_ldb(Ldb(url))
            #if it isn't already in the url store add it for further use
            if add_url_to_store :
                self.url_store_count += 1
                self.url_store.append([self.url_store_count, url])
            self.disconnect_item.set_sensitive(True)
            self.find_item.set_sensitive(True)
            self.hide_special.set_sensitive(True)
        dialog.destroy()

    def cb_open(self, button):
        dialog = Gtk.FileChooserDialog(title=_("Please choose a file"),
                    parent=self,
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
        if dialog.run() == Gtk.ResponseType.OK:
            self.set_ldb(Ldb(dialog.get_filename()))

        dialog.destroy()

    def cb_disconnect(self, button):
        self.treemodel.clear()
        self.attributemodel.clear()
        self.disconnect_item.set_sensitive(False)
        self.find_item.set_sensitive(False)
        self.hide_special.set_sensitive(False)
        self.dn_tree.set_ldb(None)
    
    def ldb_error_exception(self, err, msg=None, level=Gtk.MessageType.ERROR):
        if msg is None:
            if err is ldb.LdbError:
                code, msg = err
                
                if code == 34: return # Skip the annoying "No messages found"
                msg = _("<b>LDB Error %d</b> %s") % (code, msg)
            else:
                msg = str(err)
        self.infobar.display_message(msg, level)
    
    def refresh_attributes(self):
        """Clear and fill an attribute widget."""
        self.attributemodel.clear()
        
        if self.cur_selected_dn is None:
            # TODO show a specific "empty" screen
            self.attribute_stack.set_visible_child_name("blank")
            return
        else:
            self.attribute_stack.set_visible_child_name("attrs")
            
        try:
            msg = self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
        except IndexError:
            self.dn_label.set_text("")
            return # It's empty, ignore
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.dn_label.set_text(str(msg.dn))
        for name, el in msg.items():
            if name in ("dn", "distinguishedName"): continue
            
            el = (self.ldb.schema_format_value(name, val) for val in el)
            for val in el:
                self.attributemodel.append([name, val, True])
        
        self.attribute_add_item.set_sensitive(True)

    def toggle_special_entries(self, item):
        self.dn_tree.toggle_special_entries(not item.get_active())
        
    def cb_dn_cursor_changed(self, item):
        """Change currently selected dn and refresh attributes"""
        self.cur_selected_dn = item
        self.refresh_attributes()
        
    # START ATTRIBUTE EDITTING
    def msg_cursor_changed(self, item):
        model, iter = item.get_selection().get_selected()
        self.attribute_remove_item.set_sensitive(iter is not None)

    def add_attr_cb(self, button):
        self.add_attr()
        
    def add_attr(self):
        """Callback for the "Add" menuitem"""
        dialog = Gtk.Dialog(self, 
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_ADD, Gtk.ResponseType.OK))
        dialog.set_default_response(Gtk.ResponseType.OK)
        attr_entry = Gtk.Entry()
        attr_entry.set_text(_("Name"))
        dialog.vbox.add(attr_entry)
        value_entry = Gtk.Entry()
        value_entry.set_text(_("Value"))
        dialog.vbox.add(value_entry)
        dialog.show_all()
        
        if dialog.run() == Gtk.ResponseType.OK:
            attr = attr_entry.get_text()
            value = value_entry.get_text()
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[attr] = ldb.MessageElement(value, ldb.CHANGETYPE_ADD, attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            self.refresh_attributes()
        dialog.destroy()
    
    def delete_attr_cb(self, button):
        path, column = self.attributeview.get_cursor()
        if path is None:
            print ("Attempted to delete attr without having an attr selected")
            print ("The delete button should have been desensitized")
            return
           
        dn = str(self.cur_selected_dn)
        attr, value = self.attributemodel.get(
                self.attributemodel.get_iter(path), 0, 1)
                
        self.delete_attr(dn, str(attr), str(value))
        
    def delete_attr(self, dn, attr, value):
        """Callback for the "Remove" menuitem"""
        m = ldb.Message()
        m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
        m[attr] = ldb.MessageElement(value, ldb.CHANGETYPE_MODIFY, attr)
        
        try:
            self.ldb.modify(m)
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.refresh_attributes()
        
    def cb_msg_button_press(self, treeview, event):
        """Show right click popup menu to add or delete an element."""
        # Depends on self.cur_selected_dn
        if self.cur_selected_dn is None: return
        
        if event.button == 3:
            x = int(event.x)
            y = int(event.y)
            time = event.time
            pthinfo = treeview.get_path_at_pos(x,y)
            
            popup = Gtk.Menu()
            popup.attach_to_widget(treeview)
            if pthinfo is not None:
                path, col, cellx, celly = pthinfo
                path_str = ":".join(map(str, path))
                iter = self.attributemodel.get_iter_from_string(path_str)
                
                treeview.grab_focus()
                treeview.set_cursor(path, col, 0)
                
                dn = self.cur_selected_dn
                attr, value, editable = self.attributemodel[iter]
               
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ADD)
                el.connect('activate', lambda x: self.add_attr())
                popup.add(el) 
                
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_DELETE)
                el.connect('activate', lambda x: self.delete_attr(dn, attr, value))
                popup.add(el)
            else:
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ADD)
                el.connect('activate', lambda x: self.add_attr())
                popup.add(el)
            popup.show_all()
            popup.popup(None, None, None, None, event.button, time)
            return True
   
    def cb_msg_cell_edited(self, cell, path_string, text, column):
        """Edit the element."""
        iter = self.attributemodel.get_iter_from_string(path_string)
        old_attr, old_value, editable = self.attributemodel[iter]
        
        if column == 0: # Edited name
            if text == old_attr: return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[old_attr] = ldb.MessageElement(old_value, ldb.CHANGETYPE_MODIFY,
                                            old_attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err, Gtk.MessageType.WARNING)
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[text] = ldb.MessageElement(old_value, ldb.CHANGETYPE_ADD, text)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
        elif column == 1: # Edited value
            if text == old_value: return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[old_attr] = ldb.MessageElement(old_value, ldb.CHANGETYPE_MODIFY,
                                            old_attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err, Gtk.MessageType.WARNING)
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[old_attr] = ldb.MessageElement(text, ldb.CHANGETYPE_ADD, old_attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
        else:
            print "Edited nonexistant column #%i" % column # Shouldn't happen
            return
        self.refresh_attributes()
    # END ATTRIBUTE EDITTING

def Ldb(url):
    """Create a new LDB object.

    :param url: LDB URL to connect to.
    """
    ret = ldb.Ldb()
    path = os.getenv("LDB_MODULES_PATH")
    if path is not None:
        ret.set_modules_dir(path)
    ret.connect(url)
    return ret


if __name__ == '__main__':
    GLib.set_prgname("gtkldb")

    browser = LdbBrowser()
    if len(sys.argv) > 1:
        browser.set_ldb(Ldb(sys.argv[1]))
    browser.show_all()
    Gtk.main()
