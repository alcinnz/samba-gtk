#!/usr/bin/python

#  gtkldb
#
#  Unix SMB/CIFS implementation.
#  Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
#  Copyright (C) Dhananjay Sathe <dhananjaysathe@gmail.com> 2012
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#


"""Simple GTK frontend for LDB."""

from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GObject
from sambagtk.dialogs import get_default_logo, AboutDialog
from sambagtk import moderngtk
import gettext
gettext.install("gtkldb")
import ldb
import os
import sys

class LdbTree(object):
    CAPTION = 0
    DN = 1
    EDITABLE = 2
    PATH = 3
    ISNT_SPECIAL = 4
    
class EditorDialog(Gtk.Dialog):
    """Dialog wrapping a Gtk.TextView."""
    def __init__(self, *args, **kwargs):
        super(EditorDialog, self).__init__(*args, **kwargs)
        self.set_default_size(650, 500)
        
        self.text = Gtk.TextBuffer()
        scrolled = Gtk.ScrolledWindow()
        scrolled.add(Gtk.TextView.new_with_buffer(self.text))
        self.vbox.pack_start(scrolled, expand=True, fill=True, padding=0)
        self.set_default_response(Gtk.ResponseType.OK)
        self.show_all()
    
    def get_text(self):
        return self.text.get_text(self.text.get_start_iter(),
                    self.text.get_end_iter(), False)
    
    def set_text(self, text):
        self.text.set_text(text)

class LdbURLDialog(Gtk.Dialog):
    """Dialog that prompts for a LDB URL.
    """
    def __init__(self, parent=None,  url_store=None):

        super(LdbURLDialog, self).__init__(parent=parent,
                    buttons=(Gtk.STOCK_CANCEL,Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_OPEN,Gtk.ResponseType.OK)
                                        )
        label = Gtk.Label(_("Enter URL:"))
        self.vbox.pack_start(label, expand=True, fill=True, padding=0)
        self.url_combo_entry =  Gtk.ComboBox.new_with_model_and_entry(url_store)
        self.url_combo_entry.set_entry_text_column(1)
        self.vbox.pack_start(self.url_combo_entry, expand=True, fill=True,
        					padding=0)
        self.set_default_response(Gtk.ResponseType.OK)
        self.show_all()

    def get_url(self):
        tree_iter = self.url_combo_entry.get_active_iter()
        if tree_iter is not None:
            model = self.url_combo_entry.get_model()
            url = model[tree_iter][1]
            return (url,False)
        else:
            entry = self.url_combo_entry.get_child()
            url = entry.get_text()
            return (url,True)

        
def get_rdn(dn):
    """Get relative distinguished name.

    dn --- distinguished name
    """
    _len = dn.find(",")
    if _len == -1:
        return dn
    else:
        return dn[:_len]


class LdbBrowser(Gtk.Window):
    """Sambagtk Ldb Browser.
    """
    def __init__(self):
        super(LdbBrowser, self).__init__()
        self.url_store = Gtk.ListStore(int, str) #for history
        self.ldb = None
        self.url_store_count =0
        self.cur_selected_dn = None
        self.search_result = None
        self.create()

    def create(self):
        self.set_title(_("Sambagtk Ldb Browser Utility"))
        self.set_default_size(800, 600)
        self.set_icon_from_file(get_default_logo("samba-logo-square"))
        accel_group = Gtk.AccelGroup()

        vbox = Gtk.VBox(False, 0)
        self.add(vbox)

        #Toolbar
        self.toolbar = moderngtk.build_toolbar(self, vbox)

        self.connect_item = Gtk.ToolButton.new_from_stock(Gtk.STOCK_CONNECT)
        self.connect_item.set_tooltip_text(_("Connect to an LDB URL"))
        self.toolbar.add(self.connect_item)
        
        self.open_item = Gtk.ToolButton.new_from_stock(Gtk.STOCK_OPEN)
        self.open_item.set_tooltip_text(_("Open a LDB file"))
        self.toolbar.add(self.open_item)
        
        self.disconnect_item = Gtk.ToolButton.new_from_stock(
        											Gtk.STOCK_DISCONNECT)
        self.disconnect_item.set_tooltip_text(_("Close LDB file/connection"))
        self.disconnect_item.set_sensitive(False)
        self.toolbar.add(self.disconnect_item)
        
        self.toolbar.add(Gtk.SeparatorToolItem())
        
        self.find_item = Gtk.ToggleToolButton.new_from_stock(Gtk.STOCK_FIND)
        self.find_item.set_tooltip_text(_("Find records in open LDB file"))
        self.find_item.set_sensitive(False)
        self.toolbar.add(self.find_item)
        
        view_item = Gtk.ToolItem()
        view_button = Gtk.MenuButton()
        view_button.set_image(Gtk.Image.new_from_stock(Gtk.STOCK_PROPERTIES,
                Gtk.IconSize.LARGE_TOOLBAR))
        view_item.add(view_button)
        view_item.set_tooltip_text(_("View options..."))
        
        view_menu = Gtk.Menu()
        view_button.set_popup(view_menu)
        if hasattr(self.toolbar, 'pack_end'):
            self.toolbar.pack_end(view_item)
        else:
            self.toolbar.add(view_item)
        
        self.hide_special = Gtk.CheckMenuItem.new_with_mnemonic(
                                                    _("_Hide special entries"))
        self.hide_special.set_sensitive(False)
        view_menu.add(self.hide_special)
        
        about_item = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ABOUT)
        view_menu.add(about_item)
        view_menu.show_all()

        #   find toolbar
        self.find_revealer = Gtk.Revealer()
        find_container = Gtk.HBox()
        find_toolbar = Gtk.HBox()
        find_toolbar.set_margin_top(2)
        find_toolbar.set_margin_bottom(2)
        find_container.pack_start(find_toolbar, expand=True, fill=True,
                                    padding=0)
        find_container.get_style_context().add_class("search-bar")
        self.find_revealer.add(find_container)
        self.find_revealer.set_reveal_child(False)
        vbox.pack_start(self.find_revealer, expand=False, fill=False, padding=0)
        
        self.find_entry = Gtk.SearchEntry()
        find_toolbar.pack_start(self.find_entry, expand=True, fill=True,
                                padding=2)
        find_toolbar.pack_start(Gtk.VBox(), expand=True, fill=True, padding=2)
        
##        self.find_keys = Gtk.CheckButton.new_with_label(_("Keys"))
##        self.find_keys.set_tooltip_text(_("Search in keys"))
##        find_toolbar.pack_start(self.find_keys, expand=False, fill=False,
##                                padding=2)
##        self.find_names = Gtk.CheckButton.new_with_label(_("Value Names"))
##        self.find_names.set_tooltip_text(_("Search in value names"))
##        find_toolbar.pack_start(self.find_names, expand=False, fill=False,
##                                padding=2)
##        self.find_values = Gtk.CheckButton.new_with_label(_("Value Contents"))
##        self.find_values.set_tooltip_text(_("Search in value contents"))
##        find_toolbar.pack_start(self.find_values, expand=False, fill=False,
##                                padding=2)
##        self.find_in_whole = Gtk.CheckButton.new_with_label(
##                                                        _("Whole String Only"))
##        self.find_in_whole.set_tooltip_text(_("Search whole string"))
##        find_toolbar.pack_start(self.find_in_whole, expand=False, fill=False,
##                                padding=2)
        
        find_toolbar.show_all()

        #infobar for error reporting
        self.infobar = moderngtk.InfoBar()
        vbox.pack_start(self.infobar, expand=False, fill=False, padding=0)
        
        #main window

        pane = Gtk.HPaned()
        pane.set_position(200)
        vbox.pack_start(pane, expand=True, fill=True, padding=0)

        #   tree view
        self.treeview = Gtk.TreeView()
        self.treemodel = Gtk.TreeStore(GObject.TYPE_STRING, # caption
                                        GObject.TYPE_PYOBJECT, # dn
                                        GObject.TYPE_BOOLEAN, # editable
                                        GObject.TYPE_STRING, # path
                                        GObject.TYPE_BOOLEAN) # is special
        self.treeview.set_model(self.treemodel)
        self.treeview.set_headers_visible(False)
        self.treeview.set_tooltip_column(LdbTree.PATH)
        self.treemodel.set_sort_column_id(LdbTree.CAPTION,
                                            Gtk.SortType.ASCENDING)
        dn_renderer = Gtk.CellRendererText()
        self.treeview.append_column(Gtk.TreeViewColumn(_("_Dn"),
                                    dn_renderer, text=0, editable=2))
        
        # This class makes GtkLDB look nicer on the elementary OS theme. 
        # Feel free to add additional classes for other themes.  
        self.treeview.get_style_context().add_class('source-list')
        
        # Add an "inline" toolbar to make editting easier and more discoverable
        treeview_toolbar, treeview_box = moderngtk.build_inline_toolbar(
                self.treeview)
        
        self.treeview_add_item = Gtk.ToolButton(None, _("Create DN"))
        self.treeview_add_item.set_icon_name('list-add-symbolic')
        self.treeview_add_item.set_tooltip_text(
                    _("Create a DN based on the currently selected DN"))
        treeview_toolbar.add(self.treeview_add_item)
        
        self.treeview_remove_item = Gtk.ToolButton(None, _("Remove DN"))
        self.treeview_remove_item.set_icon_name('list-remove-symbolic')
        self.treeview_remove_item.set_tooltip_text(
                    _("Remove currently selected DN"))
        treeview_toolbar.add(self.treeview_remove_item)
        
        treeview_toolbar.add(Gtk.SeparatorToolItem())
        
        self.treeview_export_item = Gtk.ToolButton(None, _("Export LDIF"))
        self.treeview_export_item.set_icon_name('document-export-symbolic')
        self.treeview_export_item.set_tooltip_text(
                    _("Save an LDIF file for the currently selected DN")) 
        treeview_toolbar.add(self.treeview_export_item)
        
        self.treeview_edit_item = Gtk.ToolButton(None, _("Edit LDIF"))
        self.treeview_edit_item.set_icon_name('edit-symbolic')
        self.treeview_edit_item.set_tooltip_text(
                    _("Edit LDIF for the currently selected DN"))
        treeview_toolbar.add(self.treeview_edit_item)
        
        self.set_dn_toolbar_sensitive(False)
        pane.pack1(treeview_box, resize=False, shrink=True)
        
        #   Attribute view
        self.attribute_stack = Gtk.Stack()
        
        blank_attributes = Gtk.Alignment(xalign=0.5, yalign=0.5,
                                        xscale=1, yscale=1)
        blank_label = Gtk.Label(_("No DN selected.\n"
                                "Select one to view it's attributes."))
        blank_label.set_justify(Gtk.Justification.CENTER)
        blank_attributes.add(blank_label)
        self.attribute_stack.add_named(blank_attributes, "blank")

        attribute_box = Gtk.VBox()
        self.attribute_stack.add_named(attribute_box, "attrs")

        #       DN label
        self.dn_label = Gtk.Label()
        self.dn_label.set_padding(0, 5)
        self.dn_label.set_alignment(Gtk.Justification.LEFT, 
                                    Gtk.Justification.CENTER)
        self.dn_label.set_selectable(True)
        attribute_box.pack_start(self.dn_label, expand=False, fill=False,
        						padding=4)
        
        #       Attribute list
        self.attributeview = Gtk.TreeView()
        self.attributemodel = Gtk.ListStore(str, str, GObject.TYPE_BOOLEAN)
        self.attributeview.set_model(self.attributemodel)
        name_renderer = Gtk.CellRendererText()
        self.attributeview.append_column(Gtk.TreeViewColumn(_("_Name"),
                                         name_renderer, text=0, editable=2))
        value_renderer = Gtk.CellRendererText()
        self.attributeview.append_column(Gtk.TreeViewColumn(_("_Value"),
                                         value_renderer, text=1, editable=2))

        attributeview_window = Gtk.ScrolledWindow()
        attributeview_window.add(self.attributeview)
        attribute_box.pack_start(attributeview_window, expand=True, fill=True,
                                padding=6)
        
        #       Attribute toolbar
        attribute_toolbar, __ = moderngtk.build_inline_toolbar()
        
        self.attribute_add_item = Gtk.ToolButton(None, _("Add Attribute"))
        self.attribute_add_item.set_icon_name('list-add-symbolic')
        self.attribute_add_item.set_sensitive(False)
        attribute_toolbar.add(self.attribute_add_item)
        
        self.attribute_remove_item = Gtk.ToolButton(None, _("Remove Attribute"))
        self.attribute_remove_item.set_icon_name('list-remove-symbolic')
        self.attribute_remove_item.set_sensitive(False)
        attribute_toolbar.add(self.attribute_remove_item)
        
        attribute_box.pack_start(attribute_toolbar, expand=False, fill=False,
                                padding=0)
        
        pane.pack2(self.attribute_stack, shrink=True)

        # signals and connections

        self.connect('delete_event', self.on_self_delete)

        self.connect_item.connect('clicked', self.cb_connect)
        self.open_item.connect('clicked', self.cb_open)
        self.disconnect_item.connect('clicked', self.cb_disconnect)
        self.find_item.connect('clicked', self.cb_find)

        self.hide_special.connect('toggled', self.toggle_special_entries)
        about_item.connect('activate', self.show_about)
        
        self.find_entry.connect('search-changed', self.cb_search)
        
        self.treeview.connect('button_press_event', self.cb_dn_button_press)
        dn_renderer.connect('edited', self.cb_dn_cell_edited)
        self.treeview.connect('cursor_changed', self.cb_dn_cursor_changed)
        self.treeview.connect('row-expanded', self.tree_expand)
        
        self.attributeview.connect('button_press_event', self.cb_msg_button_press)
        self.attributeview.connect('cursor_changed', self.msg_cursor_changed)
        name_renderer.connect('edited', self.cb_msg_cell_edited, 0)
        value_renderer.connect('edited', self.cb_msg_cell_edited, 1)
        
        self.treeview_add_item.connect('clicked', self.add_dn_cb)
        self.treeview_remove_item.connect('clicked', self.delete_dn_cb)
        self.treeview_export_item.connect('clicked', self.export_ldif_cb)
        self.treeview_edit_item.connect('clicked', self.edit_ldif_cb)
        
        self.attribute_add_item.connect('clicked', self.add_attr_cb)
        self.attribute_remove_item.connect('clicked', self.delete_attr_cb)

        self.add_accel_group (accel_group)

    def show_about(self, widget):
        aboutwin = AboutDialog("GTK LDB",
                            _("LDB database browser/editor\n"
                            "Based on Jelmer Vernooij's original Samba-GTK"),
                            None)
        aboutwin.run()
        aboutwin.destroy()

    def on_self_delete(self, widget, event):
        Gtk.main_quit()
        return False

    def set_ldb(self, ldb):
        """Change the LDB object displayed.

        :param ldb: New LDB object to use.
        """
        self.ldb = ldb
        self.disconnect_item.set_sensitive(True)
        self.find_item.set_sensitive(True)
        self.hide_special.set_sensitive(True)
        self.treeview_add_item.set_sensitive(True)
        self.fill_tree()

    def cb_connect(self, button):
        dialog = LdbURLDialog(url_store = self.url_store)
        if dialog.run() == Gtk.ResponseType.OK:
            url,add_url_to_store = dialog.get_url()
            self.set_ldb(Ldb(url))
            #if it isn't already in the url store add it for further use
            if add_url_to_store :
                self.url_store_count += 1
                self.url_store.append([self.url_store_count, url])
            self.disconnect_item.set_sensitive(True)
            self.find_item.set_sensitive(True)
            self.hide_special.set_sensitive(True)
        dialog.destroy()

    def cb_open(self, button):
        dialog = Gtk.FileChooserDialog(title=_("Please choose a file"),
                    parent=self,
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
        if dialog.run() == Gtk.ResponseType.OK:
            self.set_ldb(Ldb(dialog.get_filename()))

        dialog.destroy()

    def cb_disconnect(self, button):
        self.treemodel.clear()
        self.attributemodel.clear()
        self.disconnect_item.set_sensitive(False)
        self.find_item.set_sensitive(False)
        self.hide_special.set_sensitive(False)
        self.set_dn_toolbar_sensitive(False)
        self.ldb = None
    
    def cb_find(self, button):
        self.find_revealer.set_reveal_child(button.get_active())
        self.find_entry.grab_focus()
        
        # Update the tree for the search mode.
        self.fill_tree()
    
    def cb_search(self, entry):
        search = entry.get_text()
        self.treemodel.clear()

        for msg in self.ldb.search(None, ldb.SCOPE_SUBTREE, search, ["dn"]):
            dn = msg.dn
            self.treemodel.append(None, [str(dn), dn, False, str(dn),
                                        not dn.is_special()])
    
    # BEGIN DN TREE LOADING
    def fill_tree(self):
        # initiate a search instead if self.find_entry is active
        if self.find_item.get_active():
            self.cb_search(self.find_entry)
            return

        self.treemodel.clear()
        
        # Attempt to find the root in order to progressively load the tree. 
        basedn = (self.ldb.get_default_basedn() or self.ldb.get_root_basedn() or 
                  self.ldb.get_config_basedn() or self.ldb.get_schema_basedn())
        if basedn:
            self.tree_append(basedn)
            return
        try:
            msgs = self.ldb.search(None, ldb.SCOPE_SUBTREE, None, ["dn"])
        except ldb.LdbError, err:
            self.infobar.display_message(err)
            return
        knownDNs = set(str(msg.dn) for msg in msgs)
        
        for msg in msgs:
            dn = msg.dn
            parent_dn = dn.parent()
            has_parent = False
            
            while parent_dn and str(parent_dn):
                if str(parent_dn) in knownDNs:
                    has_parent = True
                    break
                parent_dn = parent_dn.parent()
                
            if not has_parent:
                self.tree_append(dn)
    
    def tree_append(self, dn, tree_parent=None, dn_parent=""):
        text = str(dn)
        if dn_parent:
            name = text[:-len(str(dn_parent))].rstrip(",")
        else:
            name = text
        child = self.treemodel.append(tree_parent, [name, dn, True, text,
                                                    not dn.is_special()])
        
        # Check if DN has any children and if so add a dummy row.
        try:
            if len(self.ldb.search(dn, ldb.SCOPE_ONELEVEL, None, ["dn"])):
                # The dummy has all falsy values.
                self.treemodel.append(child, ["", None, False, "", False])
        except ldb.LdbError, err:
            self.infobar.display_message(err[1], Gtk.MessageType.WARNING)
    
    # TODO This approach to lazy loading is an ugly hack.
    #       The proper way is to subclass Gtk.TreeModel,
    #       but the Python bindings would not support that.
    # This hack is blocking drag and drop support.
    def tree_expand(self, treeview, iter_, path):
        # Quick exit if node needs no further expansion.
        child_iter = self.treemodel.iter_children(iter_)
        if not child_iter or self.treemodel.get(child_iter, 0)[0]:
            return
                
        # Add new children
        dn, dn_path = self.treemodel.get(iter_, LdbTree.DN, LdbTree.PATH)
        for msg in self.ldb.search(dn, ldb.SCOPE_ONELEVEL, None, ["dn"]):
            self.tree_append(msg.dn, iter_, dn_path)
        
        # Remove dummy child
        self.treemodel.remove(child_iter)
    # END DN TREE LOADING
    
    def ldb_error_exception(self, err):
        """Display information about an error."""
        code, msg = err
        
        if code == 34: return # Skip the annoying "No messages found"
        self.infobar.display_message(_("<b>LDB Error %d</b> %s") % (code, msg))
    
    def refresh_attributes(self):
        """Clear and fill an attribute widget."""
        self.attributemodel.clear()
        
        if self.cur_selected_dn is None:
            # TODO show a specific "empty" screen
            self.attribute_stack.set_visible_child_name("blank")
        else:
            self.attribute_stack.set_visible_child_name("attrs")
            
        try:
            msg = self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
        except IndexError:
            self.dn_label.set_text("")
            return # It's empty, ignore
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.dn_label.set_text(str(msg.dn))
        for name, el in msg.items():
            if name in ("dn", "distinguishedName"): continue
            
            el = (self.ldb.schema_format_value(name, val) for val in el)
            for val in el:
                self.attributemodel.append([name, val, True])
        
        self.attribute_add_item.set_sensitive(True)

    def toggle_special_entries(self, item):
        if item.get_active():
            filtermodel = Gtk.TreeModelFilter(child_model=self.treemodel)
            filtermodel.set_visible_column(LdbTree.ISNT_SPECIAL)
            self.treeview.set_model(filtermodel)
        else:
            self.treeview.set_model(self.treemodel)
    
    # START DN EDITTING
    def set_dn_toolbar_sensitive(self, sensitive):
        self.treeview_add_item.set_sensitive(sensitive)
        self.treeview_remove_item.set_sensitive(sensitive)
        self.treeview_export_item.set_sensitive(sensitive)
        self.treeview_edit_item.set_sensitive(sensitive)
        
    def get_selected_dn(self):
        path, column = self.treeview.get_cursor()
        if path is None:
            return ""
        return self.treemodel.get(self.treemodel.get_iter(path), 1)
    
    def add_dn_cb(self, button):
        self.add_dn(self.get_selected_dn())
        
    def add_dn(self, dn):
        """Event handler "Add" menu item."""
        dn_dialog = Gtk.Dialog(parent=self,
                        buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                                Gtk.STOCK_ADD, Gtk.ResponseType.OK))
        dn_dialog.set_default_response(Gtk.ResponseType.OK)
        dn_entry = Gtk.Entry()
        dn_entry.set_text(str(dn))
        dn_dialog.vbox.add(dn_entry)
        dn_dialog.set_title(_("Enter DN:"))
        dn_dialog.show_all()
        
        if dn_dialog.run() == Gtk.ResponseType.OK:
            dn = dn_entry.get_text()
            try:
                msg = ldb.Message(ldb.Dn(self.ldb, dn))
                # (Until recently) LDB fails when the msg has no attributes
                # so add a default "name" attribute.
                name = dn.split(",")[0]
                name = name[3:] # Chop off dn=, etc. 
                msg["name"] = name
                self.ldb.add(msg)
            except (ldb.LdbError, ValueError), err:
                self.infobar.display_message(err)
            else:
                self.fill_tree()
        dn_dialog.destroy()
    
    def delete_dn_cb(self, button):
        self.delete_dn(self.get_selected_dn())
    
    def delete_dn(self, dn):
        try:
            print dn
            self.ldb.delete(ldb.Dn(self.ldb, str(dn)))
        except (ldb.LdbError, ValueError), err:
            self.infobar.display_message(err)
        self.fill_tree()
        self.cur_selected_dn = None
        self.refresh_attributes()
        
    def get_text(self, dn):
        try:
            msg = self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
        except IndexError:
            self.infobar.show_message(_("Failed to load record '%s'.")
                                        % self.cur_selected_dn)
            return None # It's empty, ignore
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return None
        return self.ldb.write_ldif(msg, ldb.CHANGETYPE_MODIFY)
    
    def export_ldif_cb(self, button):
        self.export_ldif(self.get_selected_dn())
    
    def export_ldif(self, dn):
        dialog = Gtk.FileChooserDialog(title=_("Save LDIF"),
                        action=Gtk.FileChooserAction.SAVE,
                        parent=self,
                        buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                                Gtk.STOCK_SAVE, Gtk.ResponseType.OK))
        if dialog.run() == Gtk.ResponseType.OK:
            with open(dialog.get_filename(), 'w') as f:
                f.write(self.get_text(dn))
        dialog.destroy()
    
    def edit_ldif_cb(self, button):
        self.edit_ldif(self.get_selected_dn())
    
    def edit_ldif(self, dn):
        from tempfile import mkstemp
        
        dialog = EditorDialog(parent=self,
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_SAVE, Gtk.ResponseType.OK))
        dialog.set_text(self.get_text(dn))
        if dialog.run() == Gtk.ResponseType.OK:
            # Delete existing record...
            try:
                self.ldb.delete(ldb.Dn(self.ldb, str(dn)))
            except (ldb.LdbError, ValueError), err:
                self.infobar.display_message(err, Gtk.MessageType.WARNING)
            
            # And insert updated record
            try:
                for __, msg in self.ldb.parse_ldif(dialog.get_text()):
                    print msg
                    self.ldb.add(msg)
            except (ldb.LdbError, ValueError), err:
                self.infobar.display_message(err)
                
            # Then reload trees
            self.fill_tree()
            self.refresh_attributes()
        dialog.destroy()
        
    def cb_dn_button_press(self, treeview, event):
        """Show right click popup menu to add or delete an element."""
        # This event handler depends on self.ldb
        if self.ldb is None: return
        
        if event.button == 3:
            x = int(event.x)
            y = int(event.y)
            time = event.time
            pthinfo = treeview.get_path_at_pos(x, y)
            
            popup = Gtk.Menu()
            popup.attach_to_widget(treeview)
            if pthinfo is not None:
                path, col, cellx, celly = pthinfo
                path_str = ":".join(map(str, path))
                iter = self.treemodel.get_iter_from_string(path_str)
                
                treeview.grab_focus()
                treeview.set_cursor(path, col, 0)
                
                dn = self.treemodel[iter][1]
                
                # Now create the menu for items
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ADD)
                el.connect('activate', lambda x: self.add_dn(dn))
                popup.add(el)
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_DELETE)
                el.connect('activate', lambda x: self.delete_dn(dn))
                popup.add(el)
                el = Gtk.MenuItem.new_with_mnemonic(_("E_xport LDIF"))
                el.connect('activate', lambda x: self.export_ldif(dn))
                popup.add(el)
                el = Gtk.MenuItem.new_with_mnemonic(_("_Edit LDIF"))
                el.connect('activate', lambda x: self.edit_ldif(dn))
                popup.add(el)
            else:
                # Create the menu for the sidebar
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ADD)
                el.connect('activate', lambda x: self.add_dn(""))
                popup.add(el)
            popup.show_all()
            popup.popup(None, None, None, None, event.button, time)
            return True
  
    def cb_dn_cell_edited(self, renderer, path_string, new_rdn):
        """Rename an element"""
        iter = self.treemodel.get_iter_from_string(path_string)
        
        old_dn = self.treemodel[iter][1]
        old_rdn = get_rdn(str(old_dn))
        
        if old_rdn == new_rdn: return
        
        parent_iter = self.treemodel.iter_parent(iter.copy())
        if parent_iter:
            parent_dn = self.treemodel.get(parent_iter, LdbTree.PATH)[0]
            new_dn = new_rdn + "," + parent_dn
        
        try:
            self.ldb.rename(ldb.Dn(self.ldb, str(old_dn)), new_dn)
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.fill_tree()
    # END DN EDITTING
        
    def cb_dn_cursor_changed(self, item):
        """Change currently selected dn and refresh attributes"""
        (model, iter) = item.get_selection().get_selected()
        if iter == None:
            self.cur_selected_dn = None
            
            # Update toolbar
            self.set_dn_toolbar_sensitive(False)
            self.treeview_add_item.set_sensitive(True)
        else:
            self.cur_selected_dn = model.get_value(iter, 1)
            
            self.set_dn_toolbar_sensitive(True) # Update toolbar
        self.refresh_attributes()
        
    # START ATTRIBUTE EDITTING
    def msg_cursor_changed(self, item):
        model, iter = item.get_selection().get_selected()
        self.attribute_remove_item.set_sensitive(iter is not None)

    def add_attr_cb(self, button):
        self.add_attr()
        
    def add_attr(self):
        """Callback for the "Add" menuitem"""
        dialog = Gtk.Dialog(self, 
                    buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
                            Gtk.STOCK_ADD, Gtk.ResponseType.OK))
        dialog.set_default_response(Gtk.ResponseType.OK)
        attr_entry = Gtk.Entry()
        attr_entry.set_text(_("Name"))
        dialog.vbox.add(attr_entry)
        value_entry = Gtk.Entry()
        value_entry.set_text(_("Value"))
        dialog.vbox.add(value_entry)
        dialog.show_all()
        
        if dialog.run() == Gtk.ResponseType.OK:
            attr = attr_entry.get_text()
            value = value_entry.get_text()
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[attr] = ldb.MessageElement(value, ldb.CHANGETYPE_ADD, attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            self.refresh_attributes()
        dialog.destroy()
    
    def delete_attr_cb(self, button):
        path, column = self.attributeview.get_cursor()
        if path is None:
            print ("Attempted to delete attr without having an attr selected")
            print ("The delete button should have been desensitized")
            return
           
        dn = str(self.cur_selected_dn)
        attr, value = self.attributemodel.get(
                self.attributemodel.get_iter(path), 0, 1)
                
        self.delete_attr(dn, str(attr), str(value))
        
    def delete_attr(self, dn, attr, value):
        """Callback for the "Remove" menuitem"""
        m = ldb.Message()
        m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
        m[attr] = ldb.MessageElement(value, ldb.CHANGETYPE_MODIFY, attr)
        
        try:
            self.ldb.modify(m)
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.refresh_attributes()
        
    def cb_msg_button_press(self, treeview, event):
        """Show right click popup menu to add or delete an element."""
        # Depends on self.cur_selected_dn
        if self.cur_selected_dn is None: return
        
        if event.button == 3:
            x = int(event.x)
            y = int(event.y)
            time = event.time
            pthinfo = treeview.get_path_at_pos(x,y)
            
            popup = Gtk.Menu()
            popup.attach_to_widget(treeview)
            if pthinfo is not None:
                path, col, cellx, celly = pthinfo
                path_str = ":".join(map(str, path))
                iter = self.attributemodel.get_iter_from_string(path_str)
                
                treeview.grab_focus()
                treeview.set_cursor(path, col, 0)
                
                dn = self.cur_selected_dn
                attr, value, editable = self.attributemodel[iter]
               
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ADD)
                el.connect('activate', lambda x: self.add_attr())
                popup.add(el) 
                
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_DELETE)
                el.connect('activate', lambda x: self.delete_attr(dn, attr, value))
                popup.add(el)
            else:
                el = Gtk.ImageMenuItem.new_from_stock(Gtk.STOCK_ADD)
                el.connect('activate', lambda x: self.add_attr())
                popup.add(el)
            popup.show_all()
            popup.popup(None, None, None, None, event.button, time)
            return True
   
    def cb_msg_cell_edited(self, cell, path_string, text, column):
        """Edit the element."""
        iter = self.attributemodel.get_iter_from_string(path_string)
        old_attr, old_value, editable = self.attributemodel[iter]
        
        if column == 0: # Edited name
            if text == old_attr: return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[old_attr] = ldb.MessageElement(old_value, ldb.CHANGETYPE_MODIFY,
                                            old_attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err, Gtk.MessageType.WARNING)
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[text] = ldb.MessageElement(old_value, ldb.CHANGETYPE_ADD, text)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
        elif column == 1: # Edited value
            if text == old_value: return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[old_attr] = ldb.MessageElement(old_value, ldb.CHANGETYPE_MODIFY,
                                            old_attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err, Gtk.MessageType.WARNING)
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, str(self.cur_selected_dn))
            m[old_attr] = ldb.MessageElement(text, ldb.CHANGETYPE_ADD, old_attr)
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
        else:
            print "Edited nonexistant column #%i" % column # Shouldn't happen
            return
        self.refresh_attributes()
    # END ATTRIBUTE EDITTING

def Ldb(url):
    """Create a new LDB object.

    :param url: LDB URL to connect to.
    """
    ret = ldb.Ldb()
    path = os.getenv("LDB_MODULES_PATH")
    if path is not None:
        ret.set_modules_dir(path)
    ret.connect(url)
    return ret


if __name__ == '__main__':

    browser = LdbBrowser()
    if len(sys.argv) > 1:
        browser.set_ldb(Ldb(sys.argv[1]))
    browser.show_all()
    Gtk.main()
